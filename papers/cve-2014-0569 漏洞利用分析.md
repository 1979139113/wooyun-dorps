# cve-2014-0569 漏洞利用分析

0×00 简述
=====

来自CVE的漏洞描述：

![enter image description here](http://drops.javaweb.org/uploads/images/a06929dd186bc9c632820bc04dc4c3f20d88caf8.jpg)

测试环境： Win7 SP1 + Flash ActiveX 15.0.0.167

0×01 漏洞利用分析
=====

介绍有关漏洞关键代码前，先看一下heap spray后的内存布局：

![enter image description here](http://drops.javaweb.org/uploads/images/d7dd45f6afc5c2c80ee81be1a2fdf4d4a48c0da4.jpg)

简单描述为：

![enter image description here](http://drops.javaweb.org/uploads/images/bf4c0c073047eb04ca9e81750be7dbe6a0bbc1e3.jpg)

漏洞致使Uint Vector的length字段被改写。

漏洞关键代码：

![enter image description here](http://drops.javaweb.org/uploads/images/3ff483a2d65fa39de81d1ef05fd65f17f036df52.jpg)

红线标注的部分其操作流程：

取预定大小0×1000的ByteArray对象_loc3，赋值给domainMemory，以便casi32函数操作此内存

预置大小0×1000的ByteArray对象：

![enter image description here](http://drops.javaweb.org/uploads/images/592ee6eae6d8548d1164063ff0adbc5589a9db97.jpg)

通过函数atomicCompareAndSwapLength将_loc3长度置0

casi32函数内由于整数溢出造成执行流改变，致使向_loc3偏移0×1000处成功写入0×40000001

上述过程细节：

![enter image description here](http://drops.javaweb.org/uploads/images/2040745ab0fe533b77d068044444d2996a39207f.jpg)

![enter image description here](http://drops.javaweb.org/uploads/images/478ebd5c888309a4fb4d2253ef1b5269e5051550.jpg)

![enter image description here](http://drops.javaweb.org/uploads/images/45111efd1c470c8fe8427a5ebe4f91d53971feec.jpg)

![enter image description here](http://drops.javaweb.org/uploads/images/4b3c7f5fe4c0c88a31b29f00fafba994993b55fe.jpg)

这样就可以以超长的Uint Vector为起点，读取预置的对象数据。

利用关键点：

搜索预置的sound对象进而计算出flash控件基址

预置的sound对象包含于喷射的少量Vector Object里，这里称之为vec_3。

具体的喷射代码：

![enter image description here](http://drops.javaweb.org/uploads/images/494ab2b0f59d68e09077c83c2c2185f4f6a32234.jpg)

通过特征比对遍历以获取vec_3中元素：

![enter image description here](http://drops.javaweb.org/uploads/images/ca37089ba5e4790c466795a5a1d39025e9b62929.jpg)

搜索到的其中一项：

计算flash控件基址：

![enter image description here](http://drops.javaweb.org/uploads/images/e2de11f879456cdf8f20873fefed54526b630545.jpg)

在flash控件基址基础上获取rop链所需指令，用VirtualAlloc分配可执行内存过DEP。

![enter image description here](http://drops.javaweb.org/uploads/images/1b7472a47edf5af7d6b01772ec29ba5e4643516d.jpg)

![enter image description here](http://drops.javaweb.org/uploads/images/142baba618a6c9de4554d558cebbee5d54403172.jpg)

构造rop链（部分）：

![enter image description here](http://drops.javaweb.org/uploads/images/08adda676b58b0d23157ed6dfde4e058075807ee.jpg)

修改sound对象虚表指针，并调用修改后的虚表函数将执行流导向stack pivot。

![enter image description here](http://drops.javaweb.org/uploads/images/63e00c5d07685911eb9058fc2da02ef273855dc9.jpg)

sound对象虚表指针修改前后：

![enter image description here](http://drops.javaweb.org/uploads/images/6ab8293cdd8fe2ba4d83597cc92ec4119204dc9d.jpg)

![enter image description here](http://drops.javaweb.org/uploads/images/de60b260999feab70c4a0f3f0d55fafbd231f96d.jpg)

修改后的虚表指针指向内容：

![enter image description here](http://drops.javaweb.org/uploads/images/d5d9172f5feea89881135a3efab59aee2122b2fa.jpg)

调用虚函数触发利用。

![enter image description here](http://drops.javaweb.org/uploads/images/bdc8ed1380f7083eafd8640e43e421ad0cb9d79f.jpg)

0×02 分析总结
=====

完整的利用至少由两部分组成（html + swf），其中swf并不能独立执行，需要html传入的参数（shellcode），只拿到swf并不能获知攻击者的意图。

0×03 参考文章
=====

1.  [CVE-2014-0569漏洞分析](http://weibo.com/p/1001603769606924861349)
    
2.  [Cracking the CVE-2014-0569 nutshell](http://blogs.technet.com/b/mmpc/archive/2014/11/05/cracking-the-cve-2014-0569-nutshell.aspx)