# CVE-2015-5090漏洞利用

原文地址：http://h30499.www3.hp.com/t5/HP-Security-Research-Blog/Adobe-s-CVE-2015-5090-Updating-the-Updater-to-become-the-bossman/ba-p/6765412

0x01 前言
=====

2015年7月，Adobe修补了多个漏洞，其中CVE-2015-5090格外显眼，值得深究。但是，Adobe对于这些漏洞只是根据威胁程度进行了排名，并没有给出详情。事实上，攻击者可以利用这个bug以系统权限用来执行代码，即攻击者能够完全接管目标机器。因为这个漏洞影响的是Adobe的更新服务，也就是说，该漏洞同时存在于Adobe Reader和Acrobat Pro软件中。这两个程序都会安装ARMSvc服务（更新程序），并且都把`AdobeARM.exe/AdobeARMHelper.exe`存放在`c:\progra~1\common~1\Adobe\ARM\1.0`目录下面。

我们这里的漏洞利用方法是针对acrobat.exe的，不过，稍作修改也是可以用于Reader的。下面的视频，为大家演示了这个漏洞的利用过程。

0x02 Bug信息
=====

ARMSvc.exe支持多个由IDA中的HandlerProc函数定义的用户控件：

![enter image description here](http://drops.javaweb.org/uploads/images/7dd6fbddc2554247ff67ee0faec896a59574ff6e.jpg)

图1 Handler函数

UserControls的内部代码：

![enter image description here](http://drops.javaweb.org/uploads/images/0be4bb57c736000b30818b9846ec0925edcb0d6d.jpg)

图2 控件

对于该漏洞利用来说，我们主要感兴趣的地方在于：

170——创建一段共享内存。

179——执行ELEVATE，而ELEVATE又会使用共享内存中的参数来执行AdobeARMHelper.exe。

用户控件170的问题在于它创建了一个带有弱权限的共享内存段。 由于任何用户都能读写该共享内存段，这就意味着，攻击者能够控制传递给AdobeARMHelper.exe程序的参数。

通过观察AdobeARMHelper.exe，我们发现了例程sub_42A260，这个例程可用来寻找给定目录下面的第一个文件。之后，它会检查该文件是否带有Adobe的签名，如果是的话，sub_42A260就会把这个文件复制到AdobeARM.exe程序所在的目录下面。

![enter image description here](http://drops.javaweb.org/uploads/images/dba689db722d09958f194ff2bf544f7c8f22c944.jpg)

图3 签名校验

如果签名校验失败，该例程将退出：

![enter image description here](http://drops.javaweb.org/uploads/images/93ea0a12a5a65d83097559438bb0e2c8327ccb04.jpg)

图4 签名校验失败

如果通过了签名校验，该例程就会拷贝该文件：

![enter image description here](http://drops.javaweb.org/uploads/images/5469f9e4d41e4ef8617ab487b405828f0f738be8.jpg)

图5 签名校验成功

该函数没有考虑到以下几点：

1.  没有对存放被复制的文件的目录路径进行检查。这样，攻击者就能提供自己的路径，即把这个文件复制到攻击者指定的路径下面。
2.  找到第一个文件的时候，没有检查文件名。
3.  第一个文件被发现时，没有检查文件的扩展名。

函数DOES会进行下列检查：

1.  在指定文件夹下面找到的第一个文件是否带有Adobe的签名。利用方法：

我们能够做什么：

1.  控制SM传递给`AdobeARMHelper/AdobeARM`的参数。
2.  在需要的时候以系统权限来执行AdobeARM.exe。
3.  利用任何具有Adobe 签名的文件来覆盖AdobeARM.exe。

我们需要做什么：

1.  让无Adobe签名的代码也能执行。

策略：

为了利用这个bug，我们可以用具有Adobe签名的代码来覆盖AdobeARM.exe，并通过这些代码做一些有趣的事情。

例如，arh.exe是Adobe AIR的安装包装器。理论上，我们可以用arh.exe覆盖AdobeARM.exe，这是完全允许的，因为它也有Adobe的签名。之后，我们就可以通过arh.exe安装任意的AIR应用程序了。这个策略唯一的问题在于，arh.exe不允许向其传递参数，所以，我们无法直接通过SM向其传递参数。

最好的策略是，利用某个可以向其传递额外参数的、带有签名的二进制代码来覆盖AdobeARM.exe。利用方法：

如果我们仔细考察Acrobat Pro就会注意到，它含有一个名为AcrobatLauncher.exe的二进制程序，该程序允许通过指定的PDF文件来启动Acrobat.exe。AcrobatLauncher.exe是个好东西，因为它只会忽略额外的参数，并且既不支声，也不会退出。 具体的命令行参数为 AcrobatLauncher.exe -open PDF_FILE。

0x03 攻击链
=====

1.  触发SM。
2.  给SM写参数。
3.  触发用户控件ELEVATE，把AcrobatLauncher.exe（作为AdobeARM.exe）复制到`c:\progra~1\common~1\Adobe\ARM\1.0\AdobeARM.exe`。这基本上把更新程序覆盖掉了。
4.  运行新的adobearm.exe，它将通过我们的PDF漏洞利用代码来执行acrobat.exe程序。这一步是由ELEVATE控件自动完成的。
5.  PDF漏洞利用代码会把32.dll转储到`c:\progra~1\common~1\Adobe\ARM\1.0`目录下。这是通过我们的一种JavaScript旁路技术完成的。
6.  清除临时文件夹，这样再次调用ELEVATE时，adobearmhelper.exe就不会从临时文件夹中复制到任何东西了。
7.  重写SM，这样，它就会执行我们的新AdobeARM.exe，而不会做任何的修改了。
8.  再次执行ELEVATE，这样就会只用“-open”一个选项来执行AdobeARM.exe，以加载secur32.dll，并以SYSTEM身份弹出计算器。

从中可以看出，CVE-2015-5090为攻击者提供了一种非常可靠的方法使其可以系统权限运行代码。所以，如果你正在使用Adobe Reader 或Acrobat Pro的话，务必给这个漏洞打上补丁。此外，如果你想了解第5步中的JavaScript旁路技术的更多详情的话，请关注我们即将到来的Defcon演讲。我们拉斯维加斯见！